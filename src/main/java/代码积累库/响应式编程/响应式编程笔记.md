基于以上的一个简单事例。我们可以看出如果是响应式一定要有一个触发点。就像我们点击了计算机桌面的QQ图标一只企鹅跳啊跳。我们点击了迅雷图标有一只飞鸟在扑腾着翅膀。计算机只维护一个点击图标的事件。也就是说响应式编程一定是一个事件触发机制。并且是以异步和非阻塞的方式发送和接收的。不是我们平常请求-响应的同步模型。

事件驱动的系统通过push而不是pull来处理，生产者有消息时才推送消息给消费者，而不是通过一种浪费资源方式：让消费者不断地轮询或等待数据。

基于这个机制相对高的吞吐量和实时响应也是响应式的特点。

事件驱动由于Publisher只关心数据源，Consumer只用关心对处理结果的消费。完全是松耦合的。这就给我们很大的操作空间来定制化我们的逻辑组合，从而使异步代码更易读和可维护。

Reactor 3框架是Pivotal（Spring 母公司）基于Reactive Programming思想实现的。它实现了Reactive Streams(该规范由 Netflix、TypeSafe、Pivotal等公司发起的响应式规范)。其他诸如RxJava 2, Akka Streams, Vert.x和Ratpack也都实现了该规范。



Reactor有一个很重要概念的就是backpressure。 由于生产者消费者处理数据的能力不对等，很容易产生下游消费能力过载的问题。这就需要一个backpressure处理，来告诉上游生产者避免过载。打个比方，一个人负责放水，一个人负责接水，如果放水的速度太快，水桶势必会溅出来，接水的人会根据情况来告诉放水的人什么速度最合适，并且在快满的时候告知放水人关闭开关。



Reactor还添加了运算符的概念，这些运算符被链接在一起以描述在每个阶段对数据应用的处理。应用运算符返回一个中间Publisher（实际上，它可以被认为是上游运算符的订阅者和下游的发布者）。数据的最终归纳点在最终Subscriber中（这里还定义了用户角度的业务逻辑）。还拿放水举例，如果我们放水不是为了单纯放水而是为了制造肥宅快乐水。这样就不是一个人接水了，中间加入了原浆流程，下一个接的人接到的是原浆勾兑水，那么这个人充当了源头的消费者，也充当了他下游的生产者。他的下游还有加气儿的。他下游的下游还有罐装等一系列操作。到最后装箱整个工艺才算告一段落。另外如果下游没有开工，上游也是不开工的。这样也符合常理，不可能上游空转。


-----------------------------------
因此，基于​​NIO​​的响应式编程就是，当你做一个带有一定延迟的才能够返回的io操作时，不会阻塞，而是立刻返回一个流，并且订阅这个流，当这个流上产生了返回数据，可以立刻得到通知并调用回调函数处理数据。

背压是指订阅者能和发布者交互，可以调节发布者发布数据的速率，解决把订阅者压垮的问题。订阅者一般有request和cancel 两个方法，用于通知发布者需要数据和通知发布者不再接受数据。


​​Flux​​​和​​Mono​​​作为“数据流”的发布者，都可以发出三种“数据信号”：​​元素值​​​、​​错误信号​​​、​​完成信号​​​。当消息通知产生时，订阅者中对应的方法 ​​onNext()​​​, ​​onComplete()​​​和 ​​onError()​​会被调用。

```java
flux.subscribe(
    value -> handleData(value),
    error -> handleError(error),
    () -> handleComplete()
);
```
在Flow中定义了实现Reactive Streams的四个非常重要的组件，分别是Publisher，Subscriber，Subscription和Processor。

> 为什么要使用异步reactive
在现代应用程序中，随着用户量的增多，程序员需要考虑怎么才能提升系统的处理能力。

传统的block IO的方式，因为需要占用大量的资源，所以是不适合这样的场景的。我们需要的是NO-block IO。

JDK中提供了两种异步编程的模型：

第一种是Callbacks，异步方法可以通过传入一个Callback参数的形式来在Callback中执行异步任务。比较典型的像是java Swing中的EventListener。

第二中就是使用Future了。我们使用Callable来提交一个任务，然后通过Future来拿到它的运行结果。

这两种异步编程会有什么问题呢？

callback的问题就在于回调地狱。熟悉JS的朋友应该很理解这个回调地狱的概念。

简单点讲，回调地狱就是在callback中又使用了callback，从而造成了这种callback的层级调用关系。

而Future主要是对一个异步执行的结果进行获取，它的 get()实际上是一个block操作。并且不支持异常处理，也不支持延迟计算。

当有多个Future的组合应该怎么处理呢？JDK8 实际上引入了一个CompletableFuture类，这个类是Future也是一个CompletionStage，CompletableFuture支持then的级联操作。不过CompletableFuture提供的方法不是那么的丰富，可能满足不了我的需求。

于是我们的Reactor来了。

---
Rxjava是ReactiveX的java实现，ReactiveX家族除了Rxjava还有RxJS, Rx.NET,RxScala等等。

ReactiveX的本质就是Observer+Iterator+函数编程+异步。是一个事件驱动的，异步的，可观察的序列。
使用RxJava可以将异步的回调改写成为链式调用。在代码上看起来非常简洁明了。当然JDK也提供了CompletionStage提供了类似的解决回调的功能。

Rxjava只是一个java的基本库，如果我们想要构建响应式的服务器，响应式的web,响应式的数据访问，甚至是响应式的微服务，又该如何处理呢？

这个时候我了解到了Vert.x。Vert.x就是用来构建Reactive的应用程序的。

Vert.x是模块化的，里面有Core，web，Data access，Reactive，Microservices，MQTT，Authentication and Authorisation，Messaging，Event bus Bridge,Devops,Testing,Clustering,Services和Cloud等模块。可谓是应有尽有。

其实java界一直都在向reactive靠近，除了JDK本身的api新特性意外，比如业界有名的Spring也在spring 5中添加了webflux框架，这就是一款reactive的web框架。

在上一节我们提到了Rxjava和Vert.x,里面有一些共同的关键字，比如异步，事件驱动，观察者模式，函数式编程，消息驱动等，所有的一切都是为了让现代系统更加健壮，运行的更快，更加富有弹性，从而更好。

响应式系统需要具备这些特征：及时响应性（Responsive）、恢复性（Resilient）、有弹性（Elastic）以及消息驱动（Message Driven）。我们把具有上面四个特性的系统就叫做响应式系统。

上面的四个特性中，及时响应性（Responsive）是系统最终要达到的目标，恢复性（Resilient）和有弹性（Elastic）是系统的表现形式，而消息驱动（Message Driven）则是系统构建的手段。

使用响应式系统的架构，可以保证系统的可维护性，和可扩展性，并且在系统出现问题的时候能够有更好的可容忍性。





